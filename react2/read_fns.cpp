/***************************
This is an auto-generated file, do NOT edit!!
   generated by ./gen_sqlite
***************************/
#include <stdio.h>
#include <stdlib.h>
#include "rtcommon.h"
#include "arg.h"
#include "db_point.h"
#include "logfile.h"


/***************************/

ao_point_t *ao_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  ao_point_t *objp;
  objp = new ao_point_t;
  if (objp == NULL)
  {
    perror("new ao_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 15)
  {
    snprintf(err, esz, "Wrong number of args for ao: %d, should be 15", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->eu, sizeof(objp->eu), "%s", argv[2]);
  objp->driver = atoi(argv[3]);
  objp->card = atoi(argv[4]);
  objp->channel = atoi(argv[5]);
  objp->eu_lo = atof(argv[6]);
  objp->eu_hi = atof(argv[7]);
  objp->raw_lo = atof(argv[8]);
  objp->raw_hi = atof(argv[9]);
  objp->decimal_places = atoi(argv[10]);
  objp-> output_limit_lo = atof(argv[11]);
  objp-> output_limit_hi = atof(argv[12]);
  objp->scale_lo = atof(argv[13]);
  objp->scale_hi = atof(argv[14]);
  objp->init_values();
  return objp;
}
ao_point_t **ao_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 ao_point_t **dbps =
 (ao_point_t **) malloc(max_points * sizeof(ao_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/ao.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(ao_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (ao_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = ao_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

scan_point_t *scan_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  scan_point_t *objp;
  objp = new scan_point_t;
  if (objp == NULL)
  {
    perror("new scan_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 5)
  {
    snprintf(err, esz, "Wrong number of args for scan: %d, should be 5", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->file_name, sizeof(objp->file_name), "%s", argv[2]);
  objp->max_samples = atoi(argv[3]);
  snprintf(objp->tags, sizeof(objp->tags), "%s", argv[4]);
  objp->init_values();
  return objp;
}
scan_point_t **scan_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 scan_point_t **dbps =
 (scan_point_t **) malloc(max_points * sizeof(scan_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/scan.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(scan_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (scan_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = scan_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

pump_point_t *pump_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  pump_point_t *objp;
  objp = new pump_point_t;
  if (objp == NULL)
  {
    perror("new pump_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 8)
  {
    snprintf(err, esz, "Wrong number of args for pump: %d, should be 8", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->pump_on_tag, sizeof(objp->pump_on_tag), "%s", argv[2]);
  snprintf(objp->amps_tag, sizeof(objp->amps_tag), "%s", argv[3]);
  snprintf(objp->level_tag, sizeof(objp->level_tag), "%s", argv[4]);
  objp->min_amps = atof(argv[5]);
  objp->max_amps = atof(argv[6]);
  objp->delay = atof(argv[7]);
  objp->init_values();
  return objp;
}
pump_point_t **pump_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 pump_point_t **dbps =
 (pump_point_t **) malloc(max_points * sizeof(pump_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/pump.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(pump_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (pump_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = pump_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

discrete_value_point_t *discrete_value_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  discrete_value_point_t *objp;
  objp = new discrete_value_point_t;
  if (objp == NULL)
  {
    perror("new discrete_value_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 5)
  {
    snprintf(err, esz, "Wrong number of args for discrete_value: %d, should be 5", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->lo_desc, sizeof(objp->lo_desc), "%s", argv[2]);
  snprintf(objp->hi_desc, sizeof(objp->hi_desc), "%s", argv[3]);
  objp->initial_value = (argv[4][0] == '1') ||
             (argv[4][0] == 'T') ||
             (argv[4][0] == 't');
  objp->init_values();
  return objp;
}
discrete_value_point_t **discrete_value_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 discrete_value_point_t **dbps =
 (discrete_value_point_t **) malloc(max_points * sizeof(discrete_value_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/discrete_value.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(discrete_value_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (discrete_value_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = discrete_value_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

pid_point_t *pid_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  pid_point_t *objp;
  objp = new pid_point_t;
  if (objp == NULL)
  {
    perror("new pid_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 19)
  {
    snprintf(err, esz, "Wrong number of args for pid: %d, should be 19", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->eu, sizeof(objp->eu), "%s", argv[2]);
  objp->decimal_places = atoi(argv[3]);
  objp->setpoint_limit_hi = atof(argv[4]);
  objp->setpoint_limit_lo = atof(argv[5]);
  objp->p_gain = atof(argv[6]);
  objp->i_time = atof(argv[7]);
  objp->d_time = atof(argv[8]);
  snprintf(objp->ai_tag, sizeof(objp->ai_tag), "%s", argv[9]);
  snprintf(objp->ao_tag, sizeof(objp->ao_tag), "%s", argv[10]);
  objp->deviation_alarm = atof(argv[11]);
  objp->deviation_caution = atof(argv[12]);
  objp->deviation_delay = atof(argv[13]);
  objp->dev_alarm_enable = (argv[14][0] == '1') ||
             (argv[14][0] == 'T') ||
             (argv[14][0] == 't');
  objp->dev_alarm_shutdown = (argv[15][0] == '1') ||
             (argv[15][0] == 'T') ||
             (argv[15][0] == 't');
  objp->dev_caution_enable = (argv[16][0] == '1') ||
             (argv[16][0] == 'T') ||
             (argv[16][0] == 't');
  objp->scale_lo = atof(argv[17]);
  objp->scale_hi = atof(argv[18]);
  objp->init_values();
  return objp;
}
pid_point_t **pid_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 pid_point_t **dbps =
 (pid_point_t **) malloc(max_points * sizeof(pid_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/pid.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(pid_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (pid_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = pid_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

dcalc_point_t *dcalc_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  dcalc_point_t *objp;
  objp = new dcalc_point_t;
  if (objp == NULL)
  {
    perror("new dcalc_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 7)
  {
    snprintf(err, esz, "Wrong number of args for discrete_calc: %d, should be 7", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->expr_string, sizeof(objp->expr_string), "%s", argv[2]);
  snprintf(objp->lo_desc, sizeof(objp->lo_desc), "%s", argv[3]);
  snprintf(objp->hi_desc, sizeof(objp->hi_desc), "%s", argv[4]);
  snprintf(objp->alarm_state_str, sizeof(objp->alarm_state_str), "%s", argv[5]);
  snprintf(objp->shutdown_state_str, sizeof(objp->shutdown_state_str), "%s", argv[6]);
  objp->init_values();
  return objp;
}
dcalc_point_t **dcalc_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 dcalc_point_t **dbps =
 (dcalc_point_t **) malloc(max_points * sizeof(dcalc_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/discrete_calc.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(dcalc_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (dcalc_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = dcalc_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

timer_point_t *timer_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  timer_point_t *objp;
  objp = new timer_point_t;
  if (objp == NULL)
  {
    perror("new timer_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 7)
  {
    snprintf(err, esz, "Wrong number of args for timer: %d, should be 7", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->eu, sizeof(objp->eu), "%s", argv[2]);
  objp->decimal_places = atoi(argv[3]);
  objp->mode_count_up = (argv[4][0] == '1') ||
             (argv[4][0] == 'T') ||
             (argv[4][0] == 't');
  objp->scale_lo = atof(argv[5]);
  objp->scale_hi = atof(argv[6]);
  objp->init_values();
  return objp;
}
timer_point_t **timer_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 timer_point_t **dbps =
 (timer_point_t **) malloc(max_points * sizeof(timer_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/timer.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(timer_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (timer_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = timer_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

do_point_t *do_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  do_point_t *objp;
  objp = new do_point_t;
  if (objp == NULL)
  {
    perror("new do_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 8)
  {
    snprintf(err, esz, "Wrong number of args for do: %d, should be 8", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  objp->driver = atoi(argv[2]);
  objp->card = atoi(argv[3]);
  objp->channel = atoi(argv[4]);
  snprintf(objp->lo_desc, sizeof(objp->lo_desc), "%s", argv[5]);
  snprintf(objp->hi_desc, sizeof(objp->hi_desc), "%s", argv[6]);
  objp->invert_pv = (argv[7][0] == '1') ||
             (argv[7][0] == 'T') ||
             (argv[7][0] == 't');
  objp->init_values();
  return objp;
}
do_point_t **do_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 do_point_t **dbps =
 (do_point_t **) malloc(max_points * sizeof(do_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/do.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(do_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (do_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = do_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

web_point_t *web_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  web_point_t *objp;
  objp = new web_point_t;
  if (objp == NULL)
  {
    perror("new web_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 5)
  {
    snprintf(err, esz, "Wrong number of args for web: %d, should be 5", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  objp->update_interval = atof(argv[2]);
  snprintf(objp->template_name, sizeof(objp->template_name), "%s", argv[3]);
  snprintf(objp->output_name, sizeof(objp->output_name), "%s", argv[4]);
  objp->init_values();
  return objp;
}
web_point_t **web_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 web_point_t **dbps =
 (web_point_t **) malloc(max_points * sizeof(web_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/web.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(web_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (web_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = web_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

data_point_t *data_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  data_point_t *objp;
  objp = new data_point_t;
  if (objp == NULL)
  {
    perror("new data_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 5)
  {
    snprintf(err, esz, "Wrong number of args for data: %d, should be 5", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->file_name, sizeof(objp->file_name), "%s", argv[2]);
  objp->max_time = atoi(argv[3]);
  snprintf(objp->tags, sizeof(objp->tags), "%s", argv[4]);
  objp->init_values();
  return objp;
}
data_point_t **data_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 data_point_t **dbps =
 (data_point_t **) malloc(max_points * sizeof(data_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/data.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(data_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (data_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = data_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

discrete_logger_t *discrete_logger_t::create_one(int argc, char *argv[], char *err, int esz)
{
  discrete_logger_t *objp;
  objp = new discrete_logger_t;
  if (objp == NULL)
  {
    perror("new discrete_logger_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 5)
  {
    snprintf(err, esz, "Wrong number of args for discrete_logger: %d, should be 5", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->base_name, sizeof(objp->base_name), "%s", argv[2]);
  objp->log_hour_totals = (argv[3][0] == '1') ||
             (argv[3][0] == 'T') ||
             (argv[3][0] == 't');
  snprintf(objp->tags, sizeof(objp->tags), "%s", argv[4]);
  objp->init_values();
  return objp;
}
discrete_logger_t **discrete_logger_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 discrete_logger_t **dbps =
 (discrete_logger_t **) malloc(max_points * sizeof(discrete_logger_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/discrete_logger.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(discrete_logger_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (discrete_logger_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = discrete_logger_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

remote_pid_t *remote_pid_t::create_one(int argc, char *argv[], char *err, int esz)
{
  remote_pid_t *objp;
  objp = new remote_pid_t;
  if (objp == NULL)
  {
    perror("new remote_pid_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 24)
  {
    snprintf(err, esz, "Wrong number of args for remote_pid: %d, should be 24", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->eu, sizeof(objp->eu), "%s", argv[2]);
  objp->decimal_places = atoi(argv[3]);
  objp->setpoint_limit_hi = atof(argv[4]);
  objp->setpoint_limit_lo = atof(argv[5]);
  objp->p_gain = atof(argv[6]);
  objp->i_time = atof(argv[7]);
  objp->d_time = atof(argv[8]);
  snprintf(objp->ai_tag, sizeof(objp->ai_tag), "%s", argv[9]);
  snprintf(objp->ao_tag, sizeof(objp->ao_tag), "%s", argv[10]);
  snprintf(objp->spt_tag, sizeof(objp->spt_tag), "%s", argv[11]);
  snprintf(objp->enable_tag, sizeof(objp->enable_tag), "%s", argv[12]);
  snprintf(objp->p_tag, sizeof(objp->p_tag), "%s", argv[13]);
  snprintf(objp->i_tag, sizeof(objp->i_tag), "%s", argv[14]);
  snprintf(objp->d_tag, sizeof(objp->d_tag), "%s", argv[15]);
  objp->deviation_alarm = atof(argv[16]);
  objp->deviation_caution = atof(argv[17]);
  objp->deviation_delay = atof(argv[18]);
  objp->dev_alarm_enable = (argv[19][0] == '1') ||
             (argv[19][0] == 'T') ||
             (argv[19][0] == 't');
  objp->dev_alarm_shutdown = (argv[20][0] == '1') ||
             (argv[20][0] == 'T') ||
             (argv[20][0] == 't');
  objp->dev_caution_enable = (argv[21][0] == '1') ||
             (argv[21][0] == 'T') ||
             (argv[21][0] == 't');
  objp->scale_lo = atof(argv[22]);
  objp->scale_hi = atof(argv[23]);
  objp->init_values();
  return objp;
}
remote_pid_t **remote_pid_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 remote_pid_t **dbps =
 (remote_pid_t **) malloc(max_points * sizeof(remote_pid_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/remote_pid.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(remote_pid_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (remote_pid_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = remote_pid_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

valve_point_t *valve_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  valve_point_t *objp;
  objp = new valve_point_t;
  if (objp == NULL)
  {
    perror("new valve_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 6)
  {
    snprintf(err, esz, "Wrong number of args for valve: %d, should be 6", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->do_tag, sizeof(objp->do_tag), "%s", argv[2]);
  snprintf(objp->closed_tag, sizeof(objp->closed_tag), "%s", argv[3]);
  snprintf(objp->open_tag, sizeof(objp->open_tag), "%s", argv[4]);
  objp->delay = atof(argv[5]);
  objp->init_values();
  return objp;
}
valve_point_t **valve_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 valve_point_t **dbps =
 (valve_point_t **) malloc(max_points * sizeof(valve_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/valve.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(valve_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (valve_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = valve_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

ac_point_t *ac_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  ac_point_t *objp;
  objp = new ac_point_t;
  if (objp == NULL)
  {
    perror("new ac_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 7)
  {
    snprintf(err, esz, "Wrong number of args for ac: %d, should be 7", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->cold_temp_tag, sizeof(objp->cold_temp_tag), "%s", argv[2]);
  snprintf(objp->hot_temp_tag, sizeof(objp->hot_temp_tag), "%s", argv[3]);
  snprintf(objp->unit_running_tag, sizeof(objp->unit_running_tag), "%s", argv[4]);
  snprintf(objp->unit_disable_tag, sizeof(objp->unit_disable_tag), "%s", argv[5]);
  objp->delay = atof(argv[6]);
  objp->init_values();
  return objp;
}
ac_point_t **ac_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 ac_point_t **dbps =
 (ac_point_t **) malloc(max_points * sizeof(ac_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/ac.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(ac_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (ac_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = ac_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

ai_point_t *ai_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  ai_point_t *objp;
  objp = new ai_point_t;
  if (objp == NULL)
  {
    perror("new ai_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 23)
  {
    snprintf(err, esz, "Wrong number of args for ai: %d, should be 23", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->eu, sizeof(objp->eu), "%s", argv[2]);
  objp->driver = atoi(argv[3]);
  objp->card = atoi(argv[4]);
  objp->channel = atoi(argv[5]);
  objp->eu_lo = atof(argv[6]);
  objp->eu_hi = atof(argv[7]);
  objp->raw_lo = atof(argv[8]);
  objp->raw_hi = atof(argv[9]);
  objp->decimal_places = atoi(argv[10]);
  objp->zero_cutoff = atof(argv[11]);
  objp->lo_alarm = atof(argv[12]);
  objp->lo_caution = atof(argv[13]);
  objp->hi_caution = atof(argv[14]);
  objp->hi_alarm = atof(argv[15]);
  objp->deadband = atof(argv[16]);
  objp->lo_alarm_enable = (argv[17][0] == '1') ||
             (argv[17][0] == 'T') ||
             (argv[17][0] == 't');
  objp->lo_caution_enable = (argv[18][0] == '1') ||
             (argv[18][0] == 'T') ||
             (argv[18][0] == 't');
  objp->hi_caution_enable = (argv[19][0] == '1') ||
             (argv[19][0] == 'T') ||
             (argv[19][0] == 't');
  objp->hi_alarm_enable = (argv[20][0] == '1') ||
             (argv[20][0] == 'T') ||
             (argv[20][0] == 't');
  objp->scale_lo = atof(argv[21]);
  objp->scale_hi = atof(argv[22]);
  objp->init_values();
  return objp;
}
ai_point_t **ai_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 ai_point_t **dbps =
 (ai_point_t **) malloc(max_points * sizeof(ai_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/ai.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(ai_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (ai_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = ai_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

di_point_t *di_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  di_point_t *objp;
  objp = new di_point_t;
  if (objp == NULL)
  {
    perror("new di_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 10)
  {
    snprintf(err, esz, "Wrong number of args for di: %d, should be 10", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  objp->driver = atoi(argv[2]);
  objp->card = atoi(argv[3]);
  objp->channel = atoi(argv[4]);
  snprintf(objp->lo_desc, sizeof(objp->lo_desc), "%s", argv[5]);
  snprintf(objp->hi_desc, sizeof(objp->hi_desc), "%s", argv[6]);
  snprintf(objp->alarm_state_str, sizeof(objp->alarm_state_str), "%s", argv[7]);
  snprintf(objp->shutdown_state_str, sizeof(objp->shutdown_state_str), "%s", argv[8]);
  objp->invert_pv = (argv[9][0] == '1') ||
             (argv[9][0] == 'T') ||
             (argv[9][0] == 't');
  objp->init_values();
  return objp;
}
di_point_t **di_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 di_point_t **dbps =
 (di_point_t **) malloc(max_points * sizeof(di_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/di.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(di_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (di_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = di_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

analog_value_point_t *analog_value_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  analog_value_point_t *objp;
  objp = new analog_value_point_t;
  if (objp == NULL)
  {
    perror("new analog_value_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 7)
  {
    snprintf(err, esz, "Wrong number of args for analog_value: %d, should be 7", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->eu, sizeof(objp->eu), "%s", argv[2]);
  objp->decimal_places = atoi(argv[3]);
  objp->initial_value = atof(argv[4]);
  objp->scale_lo = atof(argv[5]);
  objp->scale_hi = atof(argv[6]);
  objp->init_values();
  return objp;
}
analog_value_point_t **analog_value_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 analog_value_point_t **dbps =
 (analog_value_point_t **) malloc(max_points * sizeof(analog_value_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/analog_value.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(analog_value_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (analog_value_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = analog_value_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

pci_point_t *pci_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  pci_point_t *objp;
  objp = new pci_point_t;
  if (objp == NULL)
  {
    perror("new pci_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 23)
  {
    snprintf(err, esz, "Wrong number of args for pci: %d, should be 23", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->eu, sizeof(objp->eu), "%s", argv[2]);
  objp->driver = atoi(argv[3]);
  objp->card = atoi(argv[4]);
  objp->channel = atoi(argv[5]);
  objp->eu_per_count = atof(argv[6]);
  objp->min_counts_for_calc = atoi(argv[7]);
  objp->rollover_count = atoi(argv[8]);
  objp->time_factor = atof(argv[9]);
  objp->decimal_places = atoi(argv[10]);
  objp->zero_cutoff = atof(argv[11]);
  objp->lo_alarm = atof(argv[12]);
  objp->lo_caution = atof(argv[13]);
  objp->hi_caution = atof(argv[14]);
  objp->hi_alarm = atof(argv[15]);
  objp->deadband = atof(argv[16]);
  objp->lo_alarm_enable = (argv[17][0] == '1') ||
             (argv[17][0] == 'T') ||
             (argv[17][0] == 't');
  objp->lo_caution_enable = (argv[18][0] == '1') ||
             (argv[18][0] == 'T') ||
             (argv[18][0] == 't');
  objp->hi_caution_enable = (argv[19][0] == '1') ||
             (argv[19][0] == 'T') ||
             (argv[19][0] == 't');
  objp->hi_alarm_enable = (argv[20][0] == '1') ||
             (argv[20][0] == 'T') ||
             (argv[20][0] == 't');
  objp->scale_lo = atof(argv[21]);
  objp->scale_hi = atof(argv[22]);
  objp->init_values();
  return objp;
}
pci_point_t **pci_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 pci_point_t **dbps =
 (pci_point_t **) malloc(max_points * sizeof(pci_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/pci.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(pci_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (pci_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = pci_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

calc_point_t *calc_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  calc_point_t *objp;
  objp = new calc_point_t;
  if (objp == NULL)
  {
    perror("new calc_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 16)
  {
    snprintf(err, esz, "Wrong number of args for calc: %d, should be 16", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->eu, sizeof(objp->eu), "%s", argv[2]);
  snprintf(objp->expr_string, sizeof(objp->expr_string), "%s", argv[3]);
  objp->decimal_places = atoi(argv[4]);
  objp->lo_alarm = atof(argv[5]);
  objp->lo_caution = atof(argv[6]);
  objp->hi_caution = atof(argv[7]);
  objp->hi_alarm = atof(argv[8]);
  objp->deadband = atof(argv[9]);
  objp->lo_alarm_enable = (argv[10][0] == '1') ||
             (argv[10][0] == 'T') ||
             (argv[10][0] == 't');
  objp->lo_caution_enable = (argv[11][0] == '1') ||
             (argv[11][0] == 'T') ||
             (argv[11][0] == 't');
  objp->hi_caution_enable = (argv[12][0] == '1') ||
             (argv[12][0] == 'T') ||
             (argv[12][0] == 't');
  objp->hi_alarm_enable = (argv[13][0] == '1') ||
             (argv[13][0] == 'T') ||
             (argv[13][0] == 't');
  objp->scale_lo = atof(argv[14]);
  objp->scale_hi = atof(argv[15]);
  objp->init_values();
  return objp;
}
calc_point_t **calc_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 calc_point_t **dbps =
 (calc_point_t **) malloc(max_points * sizeof(calc_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/calc.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(calc_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (calc_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = calc_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

file_logger_t *file_logger_t::create_one(int argc, char *argv[], char *err, int esz)
{
  file_logger_t *objp;
  objp = new file_logger_t;
  if (objp == NULL)
  {
    perror("new file_logger_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 11)
  {
    snprintf(err, esz, "Wrong number of args for file_logger: %d, should be 11", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->base_name, sizeof(objp->base_name), "%s", argv[2]);
  objp->sample_interval = atoi(argv[3]);
  objp->n_days_of_history = atoi(argv[4]);
  objp->instantaneous_enable = (argv[5][0] == '1') ||
             (argv[5][0] == 'T') ||
             (argv[5][0] == 't');
  objp->hour_enable = (argv[6][0] == '1') ||
             (argv[6][0] == 'T') ||
             (argv[6][0] == 't');
  objp->day_enable = (argv[7][0] == '1') ||
             (argv[7][0] == 'T') ||
             (argv[7][0] == 't');
  objp->week_enable = (argv[8][0] == '1') ||
             (argv[8][0] == 'T') ||
             (argv[8][0] == 't');
  objp->month_enable = (argv[9][0] == '1') ||
             (argv[9][0] == 'T') ||
             (argv[9][0] == 't');
  snprintf(objp->tags, sizeof(objp->tags), "%s", argv[10]);
  objp->init_values();
  return objp;
}
file_logger_t **file_logger_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 file_logger_t **dbps =
 (file_logger_t **) malloc(max_points * sizeof(file_logger_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/file_logger.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(file_logger_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (file_logger_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = file_logger_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}


/***************************/

level_point_t *level_point_t::create_one(int argc, char *argv[], char *err, int esz)
{
  level_point_t *objp;
  objp = new level_point_t;
  if (objp == NULL)
  {
    perror("new level_point_t");
    snprintf(err, esz, "call to 'new' failed");
    return NULL;
  }
  if (argc != 6)
  {
    snprintf(err, esz, "Wrong number of args for level: %d, should be 6", argc);
    return NULL;
  }
  snprintf(objp->tag, sizeof(objp->tag), "%s", argv[0]);
  snprintf(objp->description, sizeof(objp->description), "%s", argv[1]);
  snprintf(objp->di_hi_tag, sizeof(objp->di_hi_tag), "%s", argv[2]);
  snprintf(objp->di_lo_tag, sizeof(objp->di_lo_tag), "%s", argv[3]);
  snprintf(objp->level_tag, sizeof(objp->level_tag), "%s", argv[4]);
  objp->volume_lo_hi = atof(argv[5]);
  objp->init_values();
  return objp;
}
level_point_t **level_point_t::read(int *cnt, const char *home_dir)
{
 int max_points = 100;
 level_point_t **dbps =
 (level_point_t **) malloc(max_points * sizeof(level_point_t*));
 MALLOC_CHECK(dbps);
 *cnt = 0;
 int count = 0;
 char path[500];
 snprintf(path, sizeof(path), "%s//dbfiles/level.dat", home_dir);
 FILE *fp = fopen(path, "r");
 if (fp == NULL)
 {
   logfile->perror(path);
   logfile->vprint("Can't open %s\n", path);
   return NULL;
 }
 char line[500];
 for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
 {
   char tmp[500];
   int argc;
   char *argv[50];
   ltrim(line);
   rtrim(line);
   snprintf(tmp, sizeof(tmp), "%s", line);
   argc = get_delim_args(tmp, argv, '|', 50);
   if (argc == 0)
   {
     continue;
   }
   else if (argv[0][0] == '#')
   {
     continue;
   }
   if (count >= max_points)
   {
     max_points += 50;
     int new_size = max_points * sizeof(level_point_t*);
     logfile->vprint("Reallocating: new size = %d\n", new_size);
     dbps = (level_point_t **) realloc(dbps, new_size);
     MALLOC_CHECK(dbps);
   }
   logfile->vprint("%s\n", line);
   char errbuf[100];
   dbps[count] = level_point_t::create_one(argc, argv, errbuf, sizeof(errbuf));
   if (dbps[count] == NULL)
   {
     logfile->vprint("%s:%d\n", path, i+1);
     logfile->vprint("%s\n", errbuf);
     continue;
   }
   count++;
 }
 if (count == 0)
 {
   free(dbps);
   return NULL;
 }
 *cnt = count;
 return dbps;
}
